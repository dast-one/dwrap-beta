"""Validate input options, generate configs for ZAP, and run it
either with shell, or in the docker container.

IN:
    * CLI options, see the reference or run with --help.
    * STDIN: A JSON with Endpoints, Headers, API spec.
OUT:
    * STDOUT: subprocess.run() output
        or an acknowledgement on job started, in JSON format,
        depending on ZAP run method.
"""


import argparse
import docker
import jinja2
import json
import jsonschema
import requests
import shlex
import shutil
import subprocess
import sys
import uuid
from pathlib import Path


SCAN_REQUEST_SCH = {"type": "object", "required": ["endpoints"], "additionalProperties": False, "properties": {
    "endpoints": {"type": "array",
        "items": {"type": "string"}},
    "headers": {"type": "array",
        "items": {"type": "array", "minItems": 2, "maxItems": 2,
            "prefixItems": [{"type": "string"}, {"type": "string"}]}},
    "oas": {"type": "object",
        "properties": {
            "file": {"type": "string"},
            "url": {"type": "string"}},
        "oneOf": [
            {"required": ["file"]},
            {"required": ["url"]}]}
}}


## Parse CLI options
parser = argparse.ArgumentParser()
parser.add_argument('-o', '--out-dir', default='.') # default='/zap/wrk'
parser.add_argument('-t', '--templates-dir', default='./templates-zap') # default='/opt/masc/templates-zap'
parser.add_argument('-i', '--scan-request-from-file', default=None, help='Get scan request from JSON-file instead of STDIN.')
parser.add_argument('--job-id', default=str(uuid.uuid1()), help='Set Job Id instead of generated by default')
parser.add_argument('--docker-image', default='zap-plus', help='Override Docker image name')
parser.add_argument('--disable-active-scan', action='store_true', help='Skip ZAP Active scan')
parser.add_argument('--zap-reportfile', default='zap-report', help='Override ZAP report filename (without extension)')
# parser.add_argument('--do-not-run', action='store_true', help='Do not run Docker container')
action_grp = parser.add_mutually_exclusive_group(required=False)
action_grp.add_argument('--run-zap-docker', action='store_true', help="A method how to run ZAP. Dry run by default.")
action_grp.add_argument('--run-zap-sh', action='store_true', help="A method how to run ZAP. Dry run by default.")
args = parser.parse_args()

if args.scan_request_from_file is None:
    ## Parse STDIN data
    try:
        cfg = json.load(sys.stdin)
        jsonschema.validate(cfg, schema=SCAN_REQUEST_SCH)
    except Exception as e:
        print(type(e).__name__, str(e))
        sys.exit(1)
else:
    try:
        with open(args.scan_request_from_file) as fo:
            cfg = json.load(fo)
        jsonschema.validate(cfg, schema=SCAN_REQUEST_SCH)
    except Exception as e:
        print(type(e).__name__, str(e))
        sys.exit(1)

## Copy or download API spec. to the working dir,
## and adjust corresponding config section.
if 'oas' in cfg:
    if cfg['oas'].get('file'):
        try:
            shutil.copy(Path(cfg['oas']['file']), Path(args.out_dir))
        except shutil.SameFileError as e:
            pass
        cfg['oas'] = {'file': '/zap/wrk/' + Path(cfg['oas']['file']).name}
    elif cfg['oas'].get('url'):
        with open(Path(args.out_dir, 'oas-downloaded.txt'), 'wb') as fo:
            fo.write(requests.get(cfg['oas']['url']).content)
        cfg['oas'] = {'file': '/zap/wrk/oas-downloaded.txt'}

cfg['job_id'] = args.job_id

cfg['disable_active_scan'] = args.disable_active_scan

cfg['zap_reportfile'] = args.zap_reportfile

## Feed Jinja templates with the obtained config
jenv = jinja2.Environment(
    loader=jinja2.FileSystemLoader(args.templates_dir),
    trim_blocks=True, lstrip_blocks=True, keep_trailing_newline=True
)
jenv.globals = cfg
for template_file in [
        'zap-af.yaml.j2',      # URLs and API spec. ref. to go there
        'zap-options.cfg.j2',  # (Not parametrized yet)
        'hsendr.py.j2',        # Headers to go there
        ]:
    try:
        if template_rendered := jenv.get_template(template_file).render():
            with open(Path(args.out_dir, Path(template_file).stem), 'w') as fo:
                fo.write(template_rendered)
    except Exception as e:
        print(type(e).__name__, str(e))
        sys.exit(1)

## ZAP output will go there
Path(args.out_dir, 'out').mkdir(parents=False, exist_ok=True) # TODO: mode?

if not any((args.run_zap_docker, args.run_zap_sh)):
    sys.exit(0)


if args.run_zap_sh:
    subprocess.run(
        shlex.split('./zap.sh -cmd -autorun /zap/wrk/zap-af.yaml -configfile /zap/wrk/zap-options.cfg')
    )

if args.run_zap_docker:
    dclient = docker.from_env()
    try:
        dcontainer = dclient.containers.run(
            image=args.docker_image,
            volumes={Path(args.out_dir).resolve(): {'bind': '/zap/wrk', 'mode': 'rw'}},
            command='./zap.sh -cmd -autorun /zap/wrk/zap-af.yaml -configfile /zap/wrk/zap-options.cfg',
            auto_remove=True,
            remove=True,
            detach=True
        )
    except Exception as e:
        # (e.g. docker.errors.ImageNotFound)
        print(type(e).__name__, str(e))
        sys.exit(1)

    ## Report on Docker container start
    print(json.dumps(
        {
            'job_id': args.job_id,
            str(dcontainer): None,
            'outpath': Path(args.out_dir, 'out').resolve().as_posix(),
        }
    , indent=4))

    ## TODO: For Logging/Debug facility
    dcontainer_logstream = dcontainer.logs(stream=True, timestamps=True)
    with open(Path(args.out_dir, 'out', args.job_id + '.log'), 'wb') as fo:
        fo.writelines(dcontainer_logstream)

    dcontainer_exitstatus = dcontainer.wait()

    ## Report on Docker container finish
    print(json.dumps(
        {
            'job_id': args.job_id,
            str(dcontainer): dcontainer_exitstatus,
            'outpath': Path(args.out_dir, 'out').resolve().as_posix(),
        }
    , indent=4))

