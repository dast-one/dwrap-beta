#!/usr/bin/env python3

"""Validate input options, generate configs for ZAP, and run it
either with shell, or in the docker container.

IN:
    * CLI options, see the reference or run with --help.
    * STDIN: A JSON with Endpoints, Headers, API spec.
OUT:
    * STDOUT: subprocess.run() output
        or an acknowledgement on job started, in JSON format,
        depending on ZAP run method.
"""

import argparse
import json
import shlex
import subprocess
import sys
import uuid
import yaml
from pathlib import Path
from urllib.parse import urlparse

import jinja2
import jsonschema

from zreprt import ZapReport


SCAN_REQUEST_SCH = {"type": "object", "required": ["endpoints"], "additionalProperties": False, "properties": {
    "endpoints": {"type": "array", "minItems": 1,
        "items": {"type": "string"}},
    "headers": {"type": "array",
        "items": {"type": "array", "minItems": 2, "maxItems": 2,
            "prefixItems": [{"type": "string"}, {"type": "string"}]}},
    "oas": {"anyOf": [{"type": "null"}, {"type": "object",
        "properties": {
            "file": {"type": "string"},
            "url": {"type": "string"}},
        "oneOf": [
            {"required": ["file"]},
            {"required": ["url"]}]}]},
    "exclude_alerts": {"type": "array",
        "items": {"type": "string"}},
    "exclude_paths": {"type": "array",
        "items": {"type": "string"}},
    "proxy": {"type": "object", "properties": {
            "host": {"type": "string"},
            "port": {"type": "string"},
            "username": {"type": "string"},
            "password": {"type": "string"}
    }}
}}


# Parse CLI options
parser = argparse.ArgumentParser()
parser.add_argument('-o', '--out-dir', default='/zap/wrk')
parser.add_argument('-t', '--templates-dir', default='/usr/local/share/zap-templates')
parser.add_argument('-i', '--scan-request-from-file', default=None,
    help='Get scan request from JSON-file instead of STDIN.')
parser.add_argument('--job-id', default=str(uuid.uuid1()), help='Set Job Id instead of generated by default')
parser.add_argument('--disable-active-scan', action='store_true', help='Skip ZAP Active scan')
parser.add_argument('--zap-reportfile', default='zap-report', help='Override ZAP report filename (without extension)')
parser.add_argument('--dry-run', action='store_true', help='Prepare configs; do not run scan')
args = parser.parse_args()

if args.scan_request_from_file is None:
    # Parse STDIN data
    try:
        cfg = json.load(sys.stdin)
        jsonschema.validate(cfg, schema=SCAN_REQUEST_SCH)
    except Exception as e:
        print(type(e).__name__, str(e))
        sys.exit(1)
else:
    try:
        with open(args.scan_request_from_file) as fo:
            cfg = json.load(fo)
        jsonschema.validate(cfg, schema=SCAN_REQUEST_SCH)
    except Exception as e:
        print(type(e).__name__, str(e))
        sys.exit(1)

# Not supported by jockey. Suppressing 'oas' to avoid 'openapi' config section generation.
if 'oas' in cfg:
    del cfg['oas']

cfg['job_id'] = args.job_id

cfg['disable_active_scan'] = args.disable_active_scan

cfg['out_dir'] = Path(args.out_dir).resolve()

processed_reportfile = Path(args.zap_reportfile)
zap_raw_reportfile = processed_reportfile.with_stem(f'_{processed_reportfile.stem}')
# Reportfile in ZAP config should be specified without .json suffix
cfg['zap_reportfile'] = zap_raw_reportfile
# The rest code will use "true" reportfile name, i.e. with .json suffix
processed_reportfile = processed_reportfile.with_suffix(
    ''.join(processed_reportfile.suffixes + ['.json',]))
zap_raw_reportfile = zap_raw_reportfile.with_suffix(
    ''.join(zap_raw_reportfile.suffixes + ['.json',]))

_ep = urlparse(cfg['endpoints'][0])
zap_site = f'{_ep.scheme}://{_ep.hostname}'
cfg['zap_site'] = zap_site

# cfg['exclude_alerts'] = args.exclude_alert
if not cfg.get('exclude_alerts'):
    cfg['exclude_alerts'] = [
        '10096',  # Timestamp Disclosure
        '10027',  # Information Disclosure - Suspicious Comments
        '10109',  # Modern Web Application -- No need when ajax spider to be used
    ]

# A kind of extra safety-lock, when there are no excludes defined
if not cfg.get('exclude_paths'):
    # hostname_to_scan = re.search(r'(?:\w+?://)?([^:/]+)', cfg['endpoints'][0], re.I).group(1)
    cfg['exclude_paths'] = [
        # f'^(?:(?!https?:..{hostname_to_scan}).*).$',
        f'^(?:(?!{zap_site}).*).$',
        r'.*logout.*',
        r'.*exit',
        r'.*/static/.*',
        r'.*\.js',
        r'.*\.css',
        r'.*\.png',
        r'.*\.jpg',
        r'.*\.jpeg',
        r'.*\.svg',
    ]

# Feed Jinja templates with the obtained config
jenv = jinja2.Environment(
    loader=jinja2.FileSystemLoader(args.templates_dir),
    trim_blocks=True, lstrip_blocks=True, keep_trailing_newline=True
)
jenv.filters['to_yaml'] = yaml.dump
jenv.filters['ep2zapsite'] = lambda url: f'{urlparse(url).scheme}://{urlparse(url).hostname}'
jenv.globals = cfg
for template_file in [
        'zap-af.yaml.j2',      # URLs and API spec. ref. to go there
        'zap-options.cfg.j2',  # (Not parametrized yet)
        'hsendr.py.j2',        # Headers to go there
]:
    try:
        if template_rendered := jenv.get_template(template_file).render():
            with open(Path(args.out_dir, Path(template_file).stem), 'w') as fo:
                fo.write(template_rendered)
    except Exception as e:
        print(type(e).__name__, str(e))
        sys.exit(1)

if args.dry_run:
    print(json.dumps(vars(args), indent=4, ensure_ascii=False))
    print(json.dumps(cfg, indent=4, ensure_ascii=False))
    sys.exit(0)


subprocess.run(shlex.split(
    './zap.sh  -cmd  -autorun /zap/wrk/zap-af.yaml'
    '  -silent  -host 0.0.0.0'
    '  -configfile /zap/wrk/zap-options.cfg'
))


zr = ZapReport.from_json_file(Path(args.out_dir, zap_raw_reportfile))

while len(zr.site) > 1:
    _ = zr.site.pop(0)

for a in zr.site[0].alerts:
    for i in range(len(a.instances) - 1):
        a.instances[i].request_header = ''
        a.instances[i].request_body = ''
        a.instances[i].response_header = ''
        a.instances[i].response_body = ''

with open(Path(args.out_dir, processed_reportfile), 'w') as fo:
    fo.write(zr.json_orig())
